/*
 * capture.c
 *
 *  Created on: 4 de set de 2017
 *      Author: skelter_win
 */

#include "project_includes/capture.h"

enum analogChannelsADC0
{
    AIN0, AIN1, AIN2, AIN3, AIN4, AIN5, AIN6, AIN7, AIN_OFFSET
};

enum analogChannelsADC1
{
    AIN8, AIN9, AIN10, AIN11, AIN12, AIN13, AIN14, AIN15
};

enum fftIndex
{
    DC_SIN, DC_COS, H1_COS, H1_SIN, H2_COS, H2_SIN,
    H3_COS, H3_SIN, H4_COS, H4_SIN, H5_COS, H5_SIN,
    H6_COS, H6_SIN, H7_COS, H7_SIN, H8_COS, H8_SIN,
    H9_COS, H9_SIN, H10_COS, H10_SIN, H11_COS, H11_SIN,
    H12_COS, H12_SIN, H13_COS, H13_SIN, H14_COS, H14_SIN
};

/* global variables */
float32_t outlet1PhaseWave[SAMPLE_FRAME];      // Connected to AIN0
float32_t outlet1DiffWave[SAMPLE_FRAME];       // Connected to AIN1
float32_t outlet1Phasefft[SAMPLE_FRAME]={};

float32_t outlet2PhaseWave[SAMPLE_FRAME];      // Connected to AIN2
float32_t outlet2DiffWave[SAMPLE_FRAME];       // Connected to AIN3

float32_t outlet3PhaseWave[SAMPLE_FRAME];      // Connected to AIN4
float32_t outlet3DiffWave[SAMPLE_FRAME];       // Connected to AIN5

float32_t outlet4PhaseWave[SAMPLE_FRAME];      // Connected to AIN6
float32_t outlet4DiffWave[SAMPLE_FRAME];       // Connected to AIN7

float32_t outlet5PhaseWave[SAMPLE_FRAME];      // Connected to AIN8
float32_t outlet5DiffWave[SAMPLE_FRAME];       // Connected to AIN9

float32_t outlet6PhaseWave[SAMPLE_FRAME];      // Connected to AIN10
float32_t outlet6DiffWave[SAMPLE_FRAME];       // Connected to AIN11

float32_t outlet123VoltageWave[SAMPLE_FRAME];  // Connected to AIN12
float32_t outlet456VoltageWave[SAMPLE_FRAME];  // Connected to AIN13

float32_t debugOutlet1Phase[SAMPLE_FRAME];
float32_t debugOutlet1Diff[SAMPLE_FRAME];
float32_t debugOutlet1Voltage[SAMPLE_FRAME];

float32_t harmonics[26];

/**
 *              Calculate RMS value
 * Task created static (see RTOS_config.cfg). Process data
 * from DMA buffers and calculate rms value for AIN0...AIN15
 * If need, calculate fft for a specified channel.
 *
 */
void capture_Task(void)
{

    uint16_t i, j;
    float32_t Outlet1PhaseRMS, Outlet1DiffRMS;
    float32_t Outlet2PhaseRMS, Outlet2DiffRMS;
    float32_t Outlet3PhaseRMS, Outlet3DiffRMS;
    float32_t Outlet4PhaseRMS, Outlet4DiffRMS;
    float32_t Outlet5PhaseRMS, Outlet5DiffRMS;
    float32_t Outlet6PhaseRMS, Outlet6DiffRMS;
    float32_t Outlet123VoltageRMS, Outlet456VoltageRMS;

    while (1)
    {

        // wait here until g_uint16_adc0_ping is being filled by DMA
        Semaphore_pend(s_adc0_ping_ready, BIOS_WAIT_FOREVER);
        GPIO_write(DEBUG_PIN_CAPTURE, 1);
        // process first part of AIN0...AIN7
        for (i = 0, j = 0; i < SAMPLE_FRAME / 2; i++)
        {
            outlet1PhaseWave[i] = (float)g_uint16_adc0_ping[j + AIN0];
            outlet1DiffWave[i] = (float)g_uint16_adc0_ping[j + AIN1];
            outlet2PhaseWave[i] = (float)g_uint16_adc0_ping[j + AIN2];
            outlet2DiffWave[i] = (float)g_uint16_adc0_ping[j + AIN3];
            outlet3PhaseWave[i] = (float)g_uint16_adc0_ping[j + AIN4];
            outlet3DiffWave[i] = (float)g_uint16_adc0_ping[j + AIN5];
            outlet4PhaseWave[i] = (float)g_uint16_adc0_ping[j + AIN6];
            outlet4DiffWave[i] = (float)g_uint16_adc0_ping[j + AIN7];
            j += AIN_OFFSET;
        }
        GPIO_write(DEBUG_PIN_CAPTURE, 0);
        // wait here until g_uint16_adc1_ping is being filled by DMA
        Semaphore_pend(s_adc1_ping_ready, BIOS_WAIT_FOREVER);
        GPIO_write(DEBUG_PIN_CAPTURE, 1);
        // process first part of AIN8...AIN12
        for (i = 0, j = 0; i < SAMPLE_FRAME / 2; i++)
        {
            outlet5PhaseWave[i] = (float)g_uint16_adc1_ping[j + AIN8];
            outlet5DiffWave[i] = (float)g_uint16_adc1_ping[j + AIN9];
            outlet6PhaseWave[i] = (float)g_uint16_adc1_ping[j + AIN10];
            outlet6DiffWave[i] = (float)g_uint16_adc1_ping[j + AIN11];
            outlet123VoltageWave[i] = (float)g_uint16_adc1_ping[j + AIN12];
            outlet456VoltageWave[i] = (float)g_uint16_adc1_ping[j + AIN13];

            j += AIN_OFFSET;
        }
        GPIO_write(DEBUG_PIN_CAPTURE, 0);
        // wait here until g_uint16_adc0_pong is being filled by DMA
        Semaphore_pend(s_adc0_pong_ready, BIOS_WAIT_FOREVER);
        GPIO_write(DEBUG_PIN_CAPTURE, 1);
        // process last part of AIN0...AIN7
        for (i = 128, j = 0; i < SAMPLE_FRAME; i++)
        {
            outlet1PhaseWave[i] = (float)g_uint16_adc0_pong[j + AIN0];
            outlet1DiffWave[i] = (float)g_uint16_adc0_pong[j + AIN1];
            outlet2PhaseWave[i] = (float)g_uint16_adc0_pong[j + AIN2];
            outlet2DiffWave[i] = (float)g_uint16_adc0_pong[j + AIN3];
            outlet3PhaseWave[i] = (float)g_uint16_adc0_pong[j + AIN4];
            outlet3DiffWave[i] = (float)g_uint16_adc0_pong[j + AIN5];
            outlet4PhaseWave[i] = (float)g_uint16_adc0_pong[j + AIN6];
            outlet4DiffWave[i] = (float)g_uint16_adc0_pong[j + AIN7];
            j += AIN_OFFSET;
        }

        // apply ADC_OFFSET
        arm_offset_f32(outlet1PhaseWave, -ADC_OFFSET, outlet1PhaseWave, SAMPLE_FRAME);
        arm_offset_f32(outlet1DiffWave, -ADC_OFFSET, outlet1DiffWave,   SAMPLE_FRAME);
        arm_offset_f32(outlet2PhaseWave, -ADC_OFFSET, outlet2PhaseWave, SAMPLE_FRAME);
        arm_offset_f32(outlet2DiffWave, -ADC_OFFSET, outlet2DiffWave,   SAMPLE_FRAME);
        arm_offset_f32(outlet3PhaseWave, -ADC_OFFSET, outlet3PhaseWave, SAMPLE_FRAME);
        arm_offset_f32(outlet3DiffWave, -ADC_OFFSET, outlet3DiffWave,   SAMPLE_FRAME);
        arm_offset_f32(outlet4PhaseWave, -ADC_OFFSET, outlet4PhaseWave, SAMPLE_FRAME);
        arm_offset_f32(outlet4DiffWave, -ADC_OFFSET, outlet4DiffWave,   SAMPLE_FRAME);
        // scale to ADC_SCALE value
        arm_scale_f32(outlet1PhaseWave, ADC_SCALE, outlet1PhaseWave, SAMPLE_FRAME);
        arm_scale_f32(outlet1DiffWave, ADC_SCALE, outlet1DiffWave,   SAMPLE_FRAME);
        arm_scale_f32(outlet2PhaseWave, ADC_SCALE, outlet2PhaseWave, SAMPLE_FRAME);
        arm_scale_f32(outlet2DiffWave, ADC_SCALE, outlet2DiffWave,   SAMPLE_FRAME);
        arm_scale_f32(outlet3PhaseWave, ADC_SCALE, outlet3PhaseWave, SAMPLE_FRAME);
        arm_scale_f32(outlet3DiffWave, ADC_SCALE, outlet3DiffWave,   SAMPLE_FRAME);
        arm_scale_f32(outlet4PhaseWave, ADC_SCALE, outlet4PhaseWave, SAMPLE_FRAME);
        arm_scale_f32(outlet4DiffWave, ADC_SCALE, outlet4DiffWave,   SAMPLE_FRAME);
        // calculate rms value
        arm_rms_f32(outlet1PhaseWave, SAMPLE_FRAME, &Outlet1PhaseRMS);
        arm_rms_f32(outlet1DiffWave, SAMPLE_FRAME, &Outlet1DiffRMS);
        arm_rms_f32(outlet2PhaseWave, SAMPLE_FRAME, &Outlet2PhaseRMS);
        arm_rms_f32(outlet2DiffWave, SAMPLE_FRAME, &Outlet2DiffRMS);
        arm_rms_f32(outlet3PhaseWave, SAMPLE_FRAME, &Outlet3PhaseRMS);
        arm_rms_f32(outlet3DiffWave, SAMPLE_FRAME, &Outlet3DiffRMS);
        arm_rms_f32(outlet4PhaseWave, SAMPLE_FRAME, &Outlet4PhaseRMS);
        arm_rms_f32(outlet4DiffWave, SAMPLE_FRAME, &Outlet4DiffRMS);

        GPIO_write(DEBUG_PIN_CAPTURE, 0);
        // wait here until g_uint16_adc1_ping is being filled by DMA
        Semaphore_pend(s_adc1_pong_ready, BIOS_WAIT_FOREVER);
        GPIO_write(DEBUG_PIN_CAPTURE, 1);
        // process first part of AIN8...AIN12
        for (i = 128, j = 0; i < SAMPLE_FRAME; i++)
        {
            outlet5PhaseWave[i] = (float)g_uint16_adc1_pong[j + AIN8];
            outlet5DiffWave[i] = (float)g_uint16_adc1_pong[j + AIN9];
            outlet6PhaseWave[i] = (float)g_uint16_adc1_pong[j + AIN10];
            outlet6DiffWave[i] = (float)g_uint16_adc1_pong[j + AIN11];
            outlet123VoltageWave[i] = (float)g_uint16_adc1_pong[j + AIN12];
            outlet456VoltageWave[i] = (float)g_uint16_adc1_pong[j + AIN13];

            j += AIN_OFFSET;
        }

        // apply ADC_OFFSET
        arm_offset_f32(outlet5PhaseWave, -ADC_OFFSET, outlet5PhaseWave, SAMPLE_FRAME);
        arm_offset_f32(outlet5DiffWave, -ADC_OFFSET, outlet5DiffWave,   SAMPLE_FRAME);
        arm_offset_f32(outlet6PhaseWave, -ADC_OFFSET, outlet6PhaseWave, SAMPLE_FRAME);
        arm_offset_f32(outlet6DiffWave, -ADC_OFFSET, outlet6DiffWave,   SAMPLE_FRAME);
        arm_offset_f32(outlet123VoltageWave, -ADC_OFFSET, outlet123VoltageWave, SAMPLE_FRAME);
        arm_offset_f32(outlet456VoltageWave, -ADC_OFFSET, outlet456VoltageWave,   SAMPLE_FRAME);
        // scale to ADC_SCALE value
        arm_scale_f32(outlet5PhaseWave, ADC_SCALE, outlet5PhaseWave, SAMPLE_FRAME);
        arm_scale_f32(outlet5DiffWave, ADC_SCALE, outlet5DiffWave,   SAMPLE_FRAME);
        arm_scale_f32(outlet6PhaseWave, ADC_SCALE, outlet6PhaseWave, SAMPLE_FRAME);
        arm_scale_f32(outlet6DiffWave, ADC_SCALE, outlet6DiffWave,   SAMPLE_FRAME);
        arm_scale_f32(outlet123VoltageWave, ADC_SCALE, outlet123VoltageWave, SAMPLE_FRAME);
        arm_scale_f32(outlet456VoltageWave, ADC_SCALE, outlet456VoltageWave,   SAMPLE_FRAME);
        // calculate rms value
        arm_rms_f32(outlet5PhaseWave, SAMPLE_FRAME, &Outlet5PhaseRMS);
        arm_rms_f32(outlet5DiffWave, SAMPLE_FRAME, &Outlet5DiffRMS);
        arm_rms_f32(outlet6PhaseWave, SAMPLE_FRAME, &Outlet6PhaseRMS);
        arm_rms_f32(outlet6DiffWave, SAMPLE_FRAME, &Outlet6DiffRMS);
        arm_rms_f32(outlet123VoltageWave, SAMPLE_FRAME, &Outlet123VoltageRMS);
        arm_rms_f32(outlet456VoltageWave, SAMPLE_FRAME, &Outlet456VoltageRMS);

        // debug waves
       arm_copy_f32(outlet1PhaseWave, debugOutlet1Phase, SAMPLE_FRAME);
       arm_copy_f32(outlet1DiffWave, debugOutlet1Diff, SAMPLE_FRAME);
       arm_copy_f32(outlet123VoltageWave, debugOutlet1Voltage, SAMPLE_FRAME);

       // TODO: Create if condition to decide when fft needs to be calculated
       // create dynamic task to calculate fft
       GPIO_write(DEBUG_PIN_CAPTURE, 0);
       static int x=0;
       if (Outlet1PhaseRMS>0.5)
       {
           x++;
           if(x==2){
               x=2;
           }
       }
       else
       {
           x=0;
       }
       if(x > 3)
       {
           arm_rfft_fast_instance_f32 s;
           arm_rfft_fast_init_f32(&s, SAMPLE_FRAME);
           arm_rfft_fast_f32(&s, outlet1PhaseWave, outlet1Phasefft, 0);
           // outlet1Phasefft: [0]dc_cos, [1]dc_sin, [2]H1_cos, [3]H1_sin, [4]H2_cos, [4]H2_sin...

           Semaphore_pend(s_critical_section, BIOS_WAIT_FOREVER);
               for(i=0;i<(2 * ptgmSettingsRead.maxHarmonics)+2;i++)
               {
                   harmonics[i]=outlet1Phasefft[i];
               }

               sprintf(g_str_PostSend,
                                "TYPE=04&"
                                "OUTLET=02&"
                                "RFID=FFFF0001&"
                                "OFFSET=2228&"
                                "GAIN=4302B611&"
                                "RMS=%08X&"
                                "MV=00000000&"
                                "MV2=00000000&"
                                "UNDER=0000&"
                                "OVER=0000&"
                                "DURATION=0000&"
                                "SIN=%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X&"     // Imaginary part
                                "COS=%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X;%08X ",    // Real part
                                *(unsigned int*)&Outlet1PhaseRMS,
                                *(unsigned int*)&harmonics[H1_COS],
                                *(unsigned int*)&harmonics[H2_COS],
                                *(unsigned int*)&harmonics[H3_COS],
                                *(unsigned int*)&harmonics[H4_COS],
                                *(unsigned int*)&harmonics[H5_COS],
                                *(unsigned int*)&harmonics[H6_COS],
                                *(unsigned int*)&harmonics[H7_COS],
                                *(unsigned int*)&harmonics[H8_COS],
                                *(unsigned int*)&harmonics[H9_COS],
                                *(unsigned int*)&harmonics[H10_COS],
                                *(unsigned int*)&harmonics[H11_COS],
                                *(unsigned int*)&harmonics[H12_COS],
                                *(unsigned int*)&harmonics[H1_SIN],
                                                               *(unsigned int*)&harmonics[H2_SIN],
                                                               *(unsigned int*)&harmonics[H3_SIN],
                                                               *(unsigned int*)&harmonics[H4_SIN],
                                                               *(unsigned int*)&harmonics[H5_SIN],
                                                               *(unsigned int*)&harmonics[H6_SIN],
                                                               *(unsigned int*)&harmonics[H7_SIN],
                                                               *(unsigned int*)&harmonics[H8_SIN],
                                                               *(unsigned int*)&harmonics[H9_SIN],
                                                               *(unsigned int*)&harmonics[H10_SIN],
                                                               *(unsigned int*)&harmonics[H11_SIN],
                                                               *(unsigned int*)&harmonics[H12_SIN]);

               static Task_Handle taskHandle;
               Task_Params taskParams;
               Error_Block eb;

                   Error_init(&eb);
                   Task_Params_init(&taskParams);
                   taskParams.stackSize = HTTPTASKSTACKSIZE;
                   taskParams.priority = 1;
                   taskHandle = Task_create((Task_FuncPtr)httpTask, &taskParams, &eb);
                   if (taskHandle == NULL)
                       {
                           Log_info0("netIPAddrHook: Failed to create HTTP Task\n");
                       }
           Task_sleep(1000);

           Semaphore_post(s_critical_section);
       }
     GPIO_write(DEBUG_PIN_CAPTURE, 0);
    }
}
